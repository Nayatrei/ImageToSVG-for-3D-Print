/* Enhanced converter.js with 3D printing optimizations */
/* global ImageTracer, chrome */

document.addEventListener('DOMContentLoaded', () => {
  // --- DOM elements ---
  const elements = {
    sourceImage: document.getElementById('source-image'),
    statusText: document.getElementById('status-text'),
    generateBtn: document.getElementById('generate-btn'),
    
    // New simplified controls
    presetSelect: document.getElementById('preset'),
    // New tri-simplification sliders
    pathSimplificationSlider: document.getElementById('path-simplification'),
    pathSimplificationValue: document.getElementById('path-simplification-value'),
    cornerSharpnessSlider: document.getElementById('corner-sharpness'),
    cornerSharpnessValue: document.getElementById('corner-sharpness-value'),
    curveStraightnessSlider: document.getElementById('curve-straightness'),
    curveStraightnessValue: document.getElementById('curve-straightness-value'),
    // Color precision
    colorPrecisionSlider: document.getElementById('color-precision'),
    colorPrecisionValue: document.getElementById('color-precision-value'),
    colorFeedback: document.getElementById('color-feedback'),
    removeBgCheckbox: document.getElementById('remove-bg'),// Advanced controls (hidden by default)    
    // Preview and UI
    svgPreview: document.getElementById('svg-preview'),
    svgPreviewFiltered: document.getElementById('svg-preview-filtered'),
    qualityIndicator: document.getElementById('quality-indicator'),
    
    // File handling
    importBtn: document.getElementById('import-btn'),
    fileInput: document.getElementById('file-input'),
    urlInput: document.getElementById('url-input'),
    loadUrlBtn: document.getElementById('load-url-btn'),
    
    // Palette and layers
    paletteContainer: document.getElementById('palette-container'),
    paletteRow: document.getElementById('palette-row'),
    colorButtonsRow: document.getElementById('color-buttons-row'),
    
    // Download buttons - Enhanced for 3D printing
    downloadTinkercadBtn: document.getElementById('download-tinkercad-btn'),
    downloadSilhouetteBtn: document.getElementById('download-silhouette-btn'),
    
    // Resolution displays
    originalResolution: document.getElementById('original-resolution'),
    scaledResolution: document.getElementById('scaled-resolution')
    ,

    // Layer merging elements
    layerMergingSection: document.getElementById('layer-merging-section'),
    mergeRulesContainer: document.getElementById('merge-rules-container'),
    addMergeRuleBtn: document.getElementById('add-merge-rule-btn'),
    combineAndDownloadBtn: document.getElementById('combine-and-download-btn')
  };

  // --- Enhanced Configuration for 3D Printing ---
  const CONFIG = {
    // 3D printing optimized presets
    PRESETS_3D: {
      '3dprint': {
        // This preset's values will be mostly controlled by the simplification slider
        colorsampling: 0,
        numberofcolors: 4,
        mincolorratio: 0.02,
        rightangleenhance: true,
        strokewidth: 0,
        roundcoords: 2
      },
      'curvy': {
        ltres: 4.0, qtres: 3.0, pathomit: 8, blurradius: 2.0,
        rightangleenhance: false, linefilter: true
      },
      'sharp': {
        ltres: 0.5, qtres: 0.5, pathomit: 4, blurradius: 0,
        rightangleenhance: true, linefilter: false
      }
    },
    
    // Quality thresholds for 3D printing feedback
    QUALITY_THRESHOLDS: {
      EXCELLENT: 50,    // Under 50 paths = excellent
      GOOD: 150,        // Under 150 paths = good
      POOR: 300         // Over 300 paths = too complex
    },
    
    // Color count feedback
    COLOR_THRESHOLDS: {
      EXCELLENT: 3,     // 2-3 colors perfect for 3D printing
      GOOD: 6,          // 4-6 colors manageable
      WARNING: 10       // 7-10 colors getting complex
    }
  };

  // --- State ---
  let tracedata = null;
  let originalImageUrl = null;
  let bgEstimate = null;
  let lastOptions = null;
  let autoGeneratedOnce = false;
  let silhouetteTracedata = null;
  let silhouetteUrl = null;

  // Layer merging state
  let mergeRules = [];

  /**
   * Reset and hide the layer merging UI. Clears all existing merge rules and disables buttons.
   * This is used when a new image is loaded or before a new generation starts.
   */
  function initializeMergeUI() {
    mergeRules = [];
    if (elements.mergeRulesContainer) {
      elements.mergeRulesContainer.innerHTML = '';
    }
    // Hide the entire section so it doesn't clutter UI before generation
    if (elements.layerMergingSection) {
      elements.layerMergingSection.style.display = 'none';
    }
    // Disable buttons until we have valid layers
    if (elements.addMergeRuleBtn) {
      elements.addMergeRuleBtn.disabled = true;
    }
    if (elements.combineAndDownloadBtn) {
      elements.combineAndDownloadBtn.disabled = true;
    }
  }

  /**
   * Prepare the merge UI after a successful generation. Shows the section, clears existing rules,
   * and enables adding new rules if sufficient layers are present.
   */
  function prepareMergeUIAfterGeneration() {
    mergeRules = [];
    if (elements.mergeRulesContainer) {
      elements.mergeRulesContainer.innerHTML = '';
    }
    if (elements.layerMergingSection) {
      elements.layerMergingSection.style.display = 'block';
    }
    updateMergeRuleOptions();
  }

  /**
   * Update the options in all merge rule dropdowns based on the current visible palette.
   * Maintains existing selections where possible.
   */
  function updateMergeRuleOptions() {
    if (!elements.mergeRulesContainer) return;
    const visibleIndices = getVisiblePaletteIndices();
    const optionsHTML = visibleIndices.map((idx, ord) => `<option value="${ord}">Layer ${ord + 1}</option>`).join('');
    // Determine if we have enough layers to allow merging (at least 2)
    const canMerge = visibleIndices.length >= 2;
    if (elements.addMergeRuleBtn) {
      elements.addMergeRuleBtn.disabled = !canMerge;
    }
    // For each rule row, update select options
    const rows = Array.from(elements.mergeRulesContainer.querySelectorAll('.merge-rule-row'));
    rows.forEach((rowEl, i) => {
      const selects = rowEl.querySelectorAll('select');
      selects.forEach((sel, sindex) => {
        const currentVal = sel.value;
        sel.innerHTML = optionsHTML;
        // Try to restore previous selection if still valid
        if (visibleIndices.length > 0 && currentVal < visibleIndices.length) {
          sel.value = currentVal;
        } else {
          sel.value = '0';
        }
        // Update mergeRules accordingly
        if (mergeRules[i]) {
          if (sindex === 0) mergeRules[i].source = parseInt(sel.value);
          if (sindex === 1) mergeRules[i].target = parseInt(sel.value);
        }
      });
    });
    // Enable combine button if at least one rule is defined
    if (elements.combineAndDownloadBtn) {
      elements.combineAndDownloadBtn.disabled = mergeRules.length === 0;
    }
  }

  /**
   * Create a new merge rule row and append it to the UI. Each rule has two dropdowns (source and target)
   * and a remove button. Selections are stored in mergeRules array.
   */
  function addMergeRuleRow() {
    const visibleIndices = getVisiblePaletteIndices();
    if (visibleIndices.length < 2 || !elements.mergeRulesContainer) return;
    const ruleIndex = mergeRules.length;
    // Default: source = first visible layer, target = last visible layer
    const defaultSource = 0;
    const defaultTarget = visibleIndices.length - 1;
    mergeRules.push({ source: defaultSource, target: defaultTarget });
    // Create row container
    const row = document.createElement('div');
    row.className = 'merge-rule-row';
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.gap = '8px';
    // Label
    const labelFrom = document.createElement('span');
    labelFrom.textContent = 'Merge';
    row.appendChild(labelFrom);
    // Source select
    const sourceSelect = document.createElement('select');
    sourceSelect.innerHTML = visibleIndices.map((idx, ord) => `<option value="${ord}">Layer ${ord + 1}</option>`).join('');
    sourceSelect.value = defaultSource;
    sourceSelect.addEventListener('change', (e) => {
      mergeRules[ruleIndex].source = parseInt(e.target.value);
    });
    row.appendChild(sourceSelect);
    // Arrow
    const arrow = document.createElement('span');
    arrow.textContent = '‚Üí';
    arrow.style.fontWeight = 'bold';
    row.appendChild(arrow);
    // Target select
    const targetSelect = document.createElement('select');
    targetSelect.innerHTML = visibleIndices.map((idx, ord) => `<option value="${ord}">Layer ${ord + 1}</option>`).join('');
    targetSelect.value = defaultTarget;
    targetSelect.addEventListener('change', (e) => {
      mergeRules[ruleIndex].target = parseInt(e.target.value);
    });
    row.appendChild(targetSelect);
    // Remove button
    const removeBtn = document.createElement('button');
    removeBtn.textContent = 'Remove';
    removeBtn.style.padding = '4px 8px';
    removeBtn.style.border = '1px solid #ccc';
    removeBtn.style.borderRadius = '4px';
    removeBtn.style.background = '#f8d7da';
    removeBtn.style.color = '#721c24';
    removeBtn.style.cursor = 'pointer';
    removeBtn.addEventListener('click', () => {
      // Remove rule from state and DOM
      mergeRules.splice(ruleIndex, 1);
      row.remove();
      updateMergeRuleOptions();
    });
    row.appendChild(removeBtn);
    elements.mergeRulesContainer.appendChild(row);
    updateMergeRuleOptions();
  }

  /**
   * Given the current tracedata, visibleIndices and mergeRules, produce a new tracedata with
   * layers merged according to the rules. The mergeRules reference visibleIndices indices (0-based).
   * @param {Object} sourceData - tracedata
   * @param {number[]} visibleIndices - visible palette indices
   * @param {Array<{source:number,target:number}>} rules
   * @returns {Object} merged tracedata
   */
  function createMergedTracedata(sourceData, visibleIndices, rules) {
    if (!sourceData || !visibleIndices || visibleIndices.length === 0) return null;
    // Map each visible index to itself initially
    const finalMap = {};
    visibleIndices.forEach((idx) => {
      finalMap[idx] = idx;
    });
    // Apply each rule: source becomes target
    rules.forEach(({ source, target }) => {
      if (source === undefined || target === undefined) return;
      const srcIdx = visibleIndices[source];
      const tgtIdx = visibleIndices[target];
      // find final target (in case chained merges)
      let finalTgt = finalMap[tgtIdx];
      finalMap[srcIdx] = finalTgt;
    });
    // Build groups keyed by final index
    const groups = {};
    visibleIndices.forEach((idx) => {
      let finalIdx = finalMap[idx];
      if (!groups[finalIdx]) groups[finalIdx] = [];
      groups[finalIdx].push(idx);
    });
    // Sort group keys by their order in visibleIndices for deterministic layer ordering
    const orderedGroupKeys = visibleIndices.filter(idx => groups[idx]);
    // Compose new palette and layers
    const newPalette = [sourceData.palette[0]]; // keep background at index 0
    const newLayers = [sourceData.layers[0]];
    orderedGroupKeys.forEach((finalIdx) => {
      const group = groups[finalIdx];
      let mergedPaths = [];
      group.forEach(i => {
        const layerPaths = sourceData.layers[i];
        if (Array.isArray(layerPaths)) {
          mergedPaths = mergedPaths.concat(layerPaths);
        }
      });
      newPalette.push(sourceData.palette[finalIdx]);
      newLayers.push(mergedPaths);
    });
    return { ...sourceData, palette: newPalette, layers: newLayers };
  }

  // Listen for adding merge rule
  if (elements.addMergeRuleBtn) {
    elements.addMergeRuleBtn.addEventListener('click', () => {
      addMergeRuleRow();
    });
  }

  // Listen for combine and download button
  if (elements.combineAndDownloadBtn) {
    elements.combineAndDownloadBtn.addEventListener('click', () => {
      if (!tracedata) return alert('Generate a preview first.');
      const visibleIndices = getVisiblePaletteIndices();
      if (!visibleIndices || visibleIndices.length === 0) {
        alert('No visible layers to merge.');
        return;
      }
      if (!mergeRules || mergeRules.length === 0) {
        alert('Please add at least one merge rule.');
        return;
      }
      // Create merged tracedata
      const mergedData = createMergedTracedata(tracedata, visibleIndices, mergeRules);
      if (!mergedData) {
        alert('Failed to merge layers.');
        return;
      }
      // Download silhouette (merged base)
      let imageName = 'image';
      if (originalImageUrl) {
        imageName = originalImageUrl.split(/[\\/]/).pop().replace(/\.[^/.]+$/, '') || 'image';
      }
      const newVisibleIndices = [];
      for (let i = 1; i < mergedData.palette.length; i++) {
        if (layerHasPaths(mergedData.layers[i])) newVisibleIndices.push(i);
      }
      // Create silhouette for merged visible layers
      const subset = buildTracedataSubset(mergedData, newVisibleIndices);
      const silhouette = {
        ...subset,
        palette: subset.palette.map(() => ({ r: 0, g: 0, b: 0, a: 255 }))
      };
      const silhouetteSvg = ImageTracer.getsvgstring(silhouette, lastOptions);
      downloadSVG(silhouetteSvg, `${imageName}_merged_layer_background`);
      // Download each merged layer
      newVisibleIndices.forEach((idx, ord) => {
        const singleLayer = buildTracedataSubset(mergedData, [idx]);
        const color = mergedData.palette[idx];
        const hex = rgbToHex(color.r, color.g, color.b);
        const svgString = ImageTracer.getsvgstring(singleLayer, lastOptions);
        downloadSVG(svgString, `${imageName}_merged_layer${ord + 1}`);
      });
      elements.statusText.textContent = `‚ôªÔ∏è Merged ${newVisibleIndices.length} layer files downloaded.`;
    });
  }

  // --- Enhanced UI Setup ---
  const setupSlider = (slider, valueDisplay, decimals = 0, callback = null) => {
    if (!slider || !valueDisplay) return;
    
    const updateValue = () => {
      const value = parseFloat(slider.value);
      valueDisplay.textContent = value.toFixed(decimals);
      if (callback) callback(value);
    };
    
    slider.addEventListener('input', updateValue);
    updateValue(); // Initialize
  };

  // Setup enhanced sliders with 3D printing feedback
  setupSlider(elements.pathSimplificationSlider, elements.pathSimplificationValue, 0);
  setupSlider(elements.cornerSharpnessSlider, elements.cornerSharpnessValue, 0);
  setupSlider(elements.curveStraightnessSlider, elements.curveStraightnessValue, 0);
  setupSlider(elements.colorPrecisionSlider, elements.colorPrecisionValue, 0, updateColorFeedback);
  // Enhanced color count feedback for 3D printing
  function updateColorFeedback(colorCount) {
    if (!elements.colorFeedback) return;
    
    let feedback, className;
    if (colorCount <= CONFIG.COLOR_THRESHOLDS.EXCELLENT) {
      feedback = "‚úÖ Perfect for 3D printing";
      className = "color-feedback-excellent";
    } else if (colorCount <= CONFIG.COLOR_THRESHOLDS.GOOD) {
      feedback = "üëç Good for multi-color prints";
      className = "color-feedback-good";
    } else if (colorCount <= CONFIG.COLOR_THRESHOLDS.WARNING) {
      feedback = "‚ö†Ô∏è Complex - many print passes needed";
      className = "color-feedback-warning";
    } else {
      feedback = "‚ùå Too complex for practical 3D printing";
      className = "color-feedback-poor";
    }
    
    elements.colorFeedback.textContent = feedback;
    elements.colorFeedback.className = className;
  }

  // Initialize color feedback
  updateColorFeedback(parseInt(elements.colorPrecisionSlider.value));

  // --- 3D Printing Optimization Functions ---

  /**
   * Force solid shapes by merging similar colors
   * @param {Object} tracedata - ImageTracer tracedata object
   * @returns {Object} Solidified tracedata
   */
  function forceSolidShapes(tracedata) {
    // This is now always on
    return mergeSimilarColors(tracedata, 35); // Higher threshold = more merging
  }

  /**
   * Generate 3D printing quality assessment
   * @param {Object} tracedata - ImageTracer tracedata object
   * @returns {Object} Quality assessment
   */
  function assess3DPrintQuality(tracedata) {
    if (!tracedata) return { level: 'unknown', message: 'No data', className: '' };
    
    // Count total paths across all layers
    const totalPaths = tracedata.layers.reduce((sum, layer) => {
      return sum + (Array.isArray(layer) ? layer.length : 0);
    }, 0);
    
    const visibleColors = countVisibleLayers(tracedata);
    
    let level, message, className;
    
    if (totalPaths <= CONFIG.QUALITY_THRESHOLDS.EXCELLENT) {
      level = 'excellent';
      message = `üèÜ Excellent for 3D printing! ${totalPaths} paths, ${visibleColors} colors - perfect for Tinkercad`;
      className = 'quality-excellent';
    } else if (totalPaths <= CONFIG.QUALITY_THRESHOLDS.GOOD) {
      level = 'good';
      message = `üëç Good quality! ${totalPaths} paths, ${visibleColors} colors - should work well in Tinkercad`;
      className = 'quality-good';
    } else {
      level = 'poor';
      message = `‚ö†Ô∏è Too complex for optimal 3D printing! ${totalPaths} paths - try lowering Path Simplification or raising Color Precision`;
      className = 'quality-poor';
    }
    
    return { level, message, className, pathCount: totalPaths, colorCount: visibleColors };
  }

  /**
   * Count visible layers (excluding background and filtered colors)
   */
  function countVisibleLayers(tracedata) {
    if (!tracedata) return 0;
    
    let count = 0;
    for (let i = 1; i < tracedata.palette.length; i++) {
      const color = tracedata.palette[i];
      if (!shouldHideColor(color, i) && layerHasPaths(tracedata.layers[i])) {
        count++;
      }
    }
    return count;
  }

  // --- Enhanced Preset Handling ---
  elements.presetSelect.addEventListener('change', () => {
    // Auto-regenerate if image is loaded
    if (elements.sourceImage.src && !elements.generateBtn.disabled) {
      debounceGenerate();
    }
  });

  // --- Enhanced Generation with 3D Optimizations ---
  const debounce = (fn, ms = 300) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn(...args), ms);
    };
  };

  const debounceGenerate = debounce(() => {
    if (!elements.generateBtn.disabled) {
      elements.generateBtn.click();
    }
  }, 300);

  // Auto-regenerate on slider changes
  [elements.pathSimplificationSlider, elements.cornerSharpnessSlider, elements.curveStraightnessSlider, elements.colorPrecisionSlider].forEach(slider => {
    if (slider) {
      slider.addEventListener('input', debounceGenerate);
    }
  });

  // --- Main Generation Function ---
  elements.generateBtn.addEventListener('click', async () => {
    if (!elements.sourceImage.src) {
      alert('Please load an image before generating a preview.');
      return;
    }

    elements.statusText.textContent = '‚ö° Generating 3D-ready preview...';
    elements.generateBtn.disabled = true;
    disableDownloadButtons();
    
    // Clear quality indicator
    if (elements.qualityIndicator) {
      elements.qualityIndicator.textContent = '';
      elements.qualityIndicator.className = 'quality-indicator';
    }

    // Use setTimeout to allow UI update
    setTimeout(async () => {
      try {
        await generateSVGOptimized();
      } catch (error) {
        console.error('Generation error:', error);
        elements.statusText.textContent = '‚ùå Error during conversion. Try adjusting settings.';
      } finally {
        elements.generateBtn.disabled = false;
      }
    }, 50);
  });

  async function generateSVGOptimized() {
    // Prepare canvas at original resolution
    const width = elements.sourceImage.naturalWidth;
    const height = elements.sourceImage.naturalHeight;
    
    if (!width || !height) {
      throw new Error('Invalid image dimensions');
    }

    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    // High quality rendering
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(elements.sourceImage, 0, 0, width, height);
    
    const imageData = ctx.getImageData(0, 0, width, height);

    // Update resolution display
    if (elements.scaledResolution) {
      elements.scaledResolution.textContent = `Processing: ${width}√ó${height} pixels`;
    }

    // Optional background removal
    bgEstimate = null;
    if (elements.removeBgCheckbox && elements.removeBgCheckbox.checked) {
      bgEstimate = estimateEdgeBackground(imageData);
      knockOutBackground(imageData, bgEstimate, 30);
    }

    // Build optimized options based on preset and user settings
    const options = buildOptimizedOptions();
    lastOptions = options;

    console.log('ImageTracer options:', options);

    // Check if ImageTracer is loaded
    if (typeof ImageTracer === 'undefined' || typeof ImageTracer.imagedataToTracedata !== 'function') {
      elements.statusText.textContent = '‚ùå ImageTracer library not loaded!';
      alert('ImageTracer library is missing or not loaded.');
      return;
    }

    // Generate initial tracedata
    elements.statusText.textContent = 'üîÑ Tracing paths...';
    tracedata = ImageTracer.imagedataToTracedata(imageData, options);

    if (!tracedata || !tracedata.layers || tracedata.layers.length === 0) {
      elements.statusText.textContent = '‚ùå No paths/colors found. Try lowering simplification, increasing color count, or using a different preset.';
      alert('SVG generation failed: No paths/colors found. Try adjusting the settings or using a simpler image.');
      return;
    }

    // Apply 3D printing optimizations
    elements.statusText.textContent = 'üõ†Ô∏è Optimizing for 3D printing...';
    
    // 1. Force solid shapes if enabled
    tracedata = forceSolidShapes(tracedata);
    
    // 2. Merge similar colors for cleaner layers
    // Dynamically adjust the colour merge threshold based on precision. A high threshold merges many
    // similar colours; a low threshold preserves differences. We clamp the range so that even at high
    // precision we still merge minor shade variations (don‚Äôt exceed the base colours), and at low
    // precision we aggressively group shades together.
    const cpVal = parseInt(elements.colorPrecisionSlider.value);
    const mergeThreshold = Math.round(50 - (cpVal * 0.35)); // maps CP 0‚Üí50, 100‚Üí15
    tracedata = mergeSimilarColors(tracedata, mergeThreshold);

    // Display results
    displayPalette();
    renderPreviews();

    // Prepare merging UI now that we have tracedata
    prepareMergeUIAfterGeneration();
    
    // Quality assessment for 3D printing
    const quality = assess3DPrintQuality(tracedata);
    updateQualityDisplay(quality);
    
    // Update status and enable downloads
    elements.statusText.textContent = `‚úÖ 3D-ready preview generated! ${quality.colorCount} layers, ${quality.pathCount} paths`;
    enableDownloadButtons();
    renderColorButtons();
  }

  // **IMPROVED: This function now includes the advanced simplification logic**
  
function buildOptimizedOptions() {
    const preset = elements.presetSelect.value;

    // New tri-simplification + color precision sliders (0-100)
    const P = Math.max(0, Math.min(100, parseInt(elements.pathSimplificationSlider?.value || 40))); // Path Simplification
    const C = Math.max(0, Math.min(100, parseInt(elements.cornerSharpnessSlider?.value || 60)));    // Corner Sharpness
    const S = Math.max(0, Math.min(100, parseInt(elements.curveStraightnessSlider?.value || 40))); // Curve Straightness
    const CP = Math.max(0, Math.min(100, parseInt(elements.colorPrecisionSlider?.value || 50)));   // Color Precision

    // Helper mappers
    const map = (t, a, b) => (a + (b - a) * (t / 100));
    const mapInv = (t, a, b) => (a + (b - a) * (1 - (t / 100)));

    const w = elements.sourceImage.naturalWidth || 512;
    const h = elements.sourceImage.naturalHeight || 512;
    const rel = Math.max(0.5, Math.sqrt(w * h) / 512); // scale-aware pathomit

    // Start with defaults
    let options = Object.assign({}, ImageTracer.optionpresets.default, {
        viewbox: true,
        strokewidth: 0
    });

    // --- Mapping ---
    // 1) Path Simplification
    options.pathomit = Math.round(map(P, 0, 20) * rel);           // remove tiny paths
    options.roundcoords = Math.round(map(P, 1, 3));               // coordinate rounding
    options.blurradius = +map(P, 0, 1.2).toFixed(1);              // slight pre-smoothing
    options.blurdelta = 20;

    // 2) Corner Sharpness
    options.qtres = +mapInv(C, 4.0, 0.2).toFixed(2);              // lower = sharper corners
    options.rightangleenhance = (C >= 50);

    // 3) Curve Straightness
    options.ltres = +map(S, 0.2, 8.0).toFixed(2);                 // higher = straighter

    // 4) Color Precision
    options.colorsampling = 2;                                     // deterministic
    // Reworked colour precision mapping:
    // We want low precision to aggressively merge shaded variations into base colours, and high precision to
    // resolve distinct colours present in the source image without inventing extra shades. To achieve this, we
    // constrain the number of colours to a modest range (4‚Äí16) and adjust quantisation cycles accordingly.
    // A low CP (0‚Äì20) will produce around 4‚Äì6 colours; a high CP (80‚Äì100) will cap at around 16 colours. This
    // prevents the quantiser from producing dozens of micro‚Äëvariations when only a handful of colours exist.
    options.colorquantcycles = Math.max(1, Math.round(map(CP, 2, 8)));
    // Increase mincolorratio slightly at low precision so rare colours are merged, but still allow rarer colours
    // at high precision.
    options.mincolorratio = +mapInv(CP, 0.03, 0.0).toFixed(3);
    // Constrain numberofcolors to a moderate range (4‚Äì16) based on CP.
    // Using 0.12 instead of 0.46 yields 4 colours at CP=0 and up to ~16 at CP=100.
    options.numberofcolors = Math.max(4, Math.min(16, 4 + Math.round(CP * 0.12)));

    // Apply preset-specific tweaks last
    if (CONFIG.PRESETS_3D[preset]) {
        Object.assign(options, CONFIG.PRESETS_3D[preset]);
        // keep our computed numberofcolors and other params
    }

    // Cache for downstream (render/getsvgstring)
    lastOptions = options;
    return options;
}

  }

  function updateQualityDisplay(quality) {
    if (!elements.qualityIndicator) return;
    
    elements.qualityIndicator.textContent = quality.message;
    elements.qualityIndicator.className = `quality-indicator ${quality.className}`;
  }

  // More aggressive & sliver-aware solid base for Background (Layer 0)
function createSolidSilhouette(tracedata, holeRemovalLevel) {
  if (!tracedata) return null;

  const visibleIndices = getVisiblePaletteIndices();
  if (!visibleIndices.length) return null;

  const subset = buildTracedataSubset(tracedata, visibleIndices);

  // Merge all visible paths
  let mergedPaths = [];
  subset.layers.forEach(layer => { if (Array.isArray(layer)) mergedPaths = mergedPaths.concat(layer); });

  const w = tracedata.width || 512;
  const h = tracedata.height || 512;

  // Aggressive hole removal tuned for ‚Äúno white hairlines‚Äù
  if (holeRemovalLevel > 0) {
    const f = (holeRemovalLevel / 10);             // 0..1
    const areaThreshold = w * h * (0.005 + 0.05 * f * f); // up to ~2.5% of image area at level 10
    const minGapPx = Math.max(1, Math.round(1 + 6 * f));  // remove slivers thinner than ~1..7px
    mergedPaths = removeSmallHoles(mergedPaths, {
      areaThreshold,
      minGapPx,
      imageW: w,
      imageH: h
    });
  }

  return {
    width: subset.width,
    height: subset.height,
    layers: [mergedPaths],
    palette: [{ r: 0, g: 0, b: 0, a: 255 }]
  };
}

  function renderPreviews() {
    if (!tracedata) return;
    
    // Main preview with all visible layers
    const visibleIndices = getVisiblePaletteIndices();
    const previewData = visibleIndices.length 
      ? buildTracedataSubset(tracedata, visibleIndices)
      : Object.assign({}, tracedata, { layers: [], palette: [] });

    const svgString = ImageTracer.getsvgstring(previewData, lastOptions);
    const blob = new Blob([svgString], { type: 'image/svg+xml' });
    elements.svgPreview.data = URL.createObjectURL(blob);

    // Generate solid silhouette for background layer
    const holeRemovalLevel = 1; // Default to level 1
    silhouetteTracedata = createSolidSilhouette(tracedata, holeRemovalLevel);
    
    if (silhouetteTracedata) {
      const silhouetteSvg = ImageTracer.getsvgstring(silhouetteTracedata, lastOptions);
      const silhouetteBlob = new Blob([silhouetteSvg], { type: 'image/svg+xml' });
      silhouetteUrl = URL.createObjectURL(silhouetteBlob);
    }

    // after we build silhouetteUrl, before updateFilteredPreview()
    selectBackgroundLayerOnly();
    // Update filtered preview
    updateFilteredPreview();
  }

  // --- Enhanced Download Functions ---
  
  elements.downloadTinkercadBtn?.addEventListener('click', () => {
    if (!tracedata) return alert('Generate a preview first.');
    const visibleIndices = getVisiblePaletteIndices();
    if (!visibleIndices.length) return alert('No visible layers to export.');

    let imageName = 'image';
    if (originalImageUrl) {
      imageName = originalImageUrl.split(/[\\/]/).pop().replace(/\.[^/.]+$/, '') || 'image';
    }

    // 1. Download Silhouette / Merged Base
    const subset = buildTracedataSubset(tracedata, visibleIndices);
    const silhouette = {
      ...subset,
      palette: subset.palette.map(() => ({ r: 0, g: 0, b: 0, a: 255 }))
    };
    const svgStringSilhouette = ImageTracer.getsvgstring(silhouette, lastOptions);
    downloadSVG(svgStringSilhouette, `${imageName}_layer_background`);

    // 2. Download all visible layers individually
    visibleIndices.forEach((idx, ordinal) => {
      const singleLayer = buildTracedataSubset(tracedata, [idx]);
      const svgString = ImageTracer.getsvgstring(singleLayer, lastOptions);
      downloadSVG(svgString, `${imageName}_layer${ordinal + 1}`);
    });

    elements.statusText.textContent = `üé≠ Background and ${visibleIndices.length} layer files downloaded.`;
  });

  elements.downloadSilhouetteBtn?.addEventListener('click', () => {
    if (!tracedata) return alert('Generate a preview first.');
    
    // Use the processed solid silhouette if available
    if (silhouetteTracedata) {
      const svgString = ImageTracer.getsvgstring(silhouetteTracedata, lastOptions);
      downloadSVG(svgString, 'solid-base-silhouette');
      elements.statusText.textContent = 'üé≠ Solid base downloaded! Import as bottom layer in Tinkercad.';
      return;
    }
    
    // Fallback: create silhouette on demand
    const holeRemovalLevel = 1; // Default to level 1
    const solidSilhouette = createSolidSilhouette(tracedata, holeRemovalLevel);
    
    if (solidSilhouette) {
      const svgString = ImageTracer.getsvgstring(solidSilhouette, lastOptions);
      downloadSVG(svgString, 'solid-base-silhouette');
      elements.statusText.textContent = 'üé≠ Solid base downloaded! Import as bottom layer in Tinkercad.';
    } else {
      alert('Unable to create silhouette. Try generating a preview first.');
    }
  });

  // --- Utility Functions ---
  
  function downloadSVG(svgContent, baseName) {
    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${baseName || 'converted'}.svg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function rgbToHex(r, g, b) {
    return [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
  }

  function enableDownloadButtons() {
    [elements.downloadTinkercadBtn, elements.downloadSilhouetteBtn].forEach(btn => {
      if (btn) btn.disabled = false;
    });
  }

  function disableDownloadButtons() {
    [elements.downloadTinkercadBtn, elements.downloadSilhouetteBtn].forEach(btn => {
      if (btn) btn.disabled = true;
    });
  }

  // --- Image Loading Functions ---
  
  elements.importBtn?.addEventListener('click', () => {
    elements.fileInput?.click();
  });

  elements.fileInput?.addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.type.startsWith('image/')) {
      alert('Please select a valid image file.');
      return;
    }

    elements.statusText.textContent = 'üìÅ Loading your image...';
    const reader = new FileReader();
    
    reader.onload = (e) => {
      resetAutoGenerateFlag();
      elements.sourceImage.src = e.target.result;
      originalImageUrl = file.name;
    };
    
    reader.onerror = () => {
      elements.statusText.textContent = '‚ùå Error loading image file.';
    };
    
    reader.readAsDataURL(file);
  });

  elements.loadUrlBtn?.addEventListener('click', async () => {
    const url = elements.urlInput?.value?.trim();
    if (!url) {
      alert('Please enter an image URL.');
      return;
    }
    await loadImageFromUrl(url);
  });

  async function loadImageFromUrl(url) {
    elements.statusText.textContent = 'üåê Fetching image from URL...';
    originalImageUrl = url;
    
    try {
      if (url.startsWith('data:')) {
        elements.sourceImage.src = url;
        return;
      }

      // Try background script fetch if available (Chrome extension)
      if (typeof chrome !== 'undefined' && chrome.runtime?.connect) {
        const port = chrome.runtime.connect({ name: 'fetchImagePort' });
        
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            port.disconnect();
            reject(new Error('Timeout'));
          }, 10000);

          port.postMessage({ type: 'fetchImage', url });
          port.onMessage.addListener((response) => {
            clearTimeout(timeout);
            if (response.dataUrl) {
              resetAutoGenerateFlag();
              elements.sourceImage.src = response.dataUrl;
              resolve();
            } else {
              reject(new Error(response.error || 'Failed to fetch'));
            }
            port.disconnect();
          });
        });
      }

      // Fallback: direct fetch or CORS proxy
      let response;
      try {
        response = await fetch(url, { mode: 'cors' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
      } catch (corsError) {
        const proxyUrl = 'https://images.weserv.nl/?url=' + encodeURIComponent(url);
        response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`Proxy failed: HTTP ${response.status}`);
      }

      const blob = await response.blob();
      const dataUrl = await new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });

      elements.sourceImage.src = dataUrl;
      resetAutoGenerateFlag();
      elements.statusText.textContent = '‚úÖ Image loaded successfully!';

    } catch (error) {
      console.error('URL load error:', error);
      elements.statusText.textContent = '‚ùå Failed to load image from URL. Try downloading and importing locally.';
    }
  }

  elements.sourceImage.onload = () => {
    elements.sourceImage.style.display = 'block';
    elements.generateBtn.disabled = false;
    
    if (elements.originalResolution) {
      const w = elements.sourceImage.naturalWidth;
      const h = elements.sourceImage.naturalHeight;
      elements.originalResolution.textContent = `Original: ${w}√ó${h} pixels`;
    }

    if (elements.scaledResolution) {
      elements.scaledResolution.textContent = '';
    }

    if (elements.removeBgCheckbox) {
      const hasTransparency = detectTransparency(elements.sourceImage);
      elements.removeBgCheckbox.disabled = hasTransparency;
      elements.removeBgCheckbox.checked = !hasTransparency;
      
      if (hasTransparency) {
        elements.statusText.textContent = 'üñºÔ∏è Image loaded! (Transparency detected - background removal disabled)';
      } else {
        elements.statusText.textContent = 'üñºÔ∏è Image loaded! Auto-generating 3D-ready preview...';
      }
    }

    if (!autoGeneratedOnce) {
      autoGeneratedOnce = true;
      setTimeout(() => {
        if (elements.presetSelect.value !== '3dprint') {
          elements.presetSelect.value = '3dprint';
        }
        elements.generateBtn.click();
      }, 100);
    }
  };

  function resetAutoGenerateFlag() {
    autoGeneratedOnce = false;
    // Reset merge UI when starting a new image
    initializeMergeUI();
  }

  // --- Helper Functions ---
  
  function detectTransparency(img) {
    const canvas = document.createElement('canvas');
    canvas.width = Math.min(img.naturalWidth, 100); // Sample for performance
    canvas.height = Math.min(img.naturalHeight, 100);
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] < 250) return true;
    }
    return false;
  }

  function estimateEdgeBackground(imageData) {
    const { width, height, data } = imageData;
    let r = 0, g = 0, b = 0, count = 0;
    const step = Math.max(1, Math.floor(Math.min(width, height) / 50));
    
    const sample = (x, y) => {
      const i = (y * width + x) * 4;
      r += data[i]; g += data[i + 1]; b += data[i + 2]; count++;
    };
    
    for (let x = 0; x < width; x += step) {
      sample(x, 0); sample(x, height - 1);
    }
    for (let y = 0; y < height; y += step) {
      sample(0, y); sample(width - 1, y);
    }
    
    return { 
      r: Math.round(r / count), 
      g: Math.round(g / count), 
      b: Math.round(b / count), 
      a: 255 
    };
  }

  function knockOutBackground(imageData, bgColor, threshold = 30) {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const distance = Math.abs(data[i] - bgColor.r) + 
                       Math.abs(data[i + 1] - bgColor.g) + 
                       Math.abs(data[i + 2] - bgColor.b);
      if (distance <= threshold) {
        data[i + 3] = 0; // Make transparent
      }
    }
  }

  function mergeSimilarColors(tracedata, threshold) {
    if (!tracedata || !tracedata.palette) return tracedata;
    
    const { palette, layers } = tracedata;
    const used = new Array(palette.length).fill(false);
    const groups = [];
    
    for (let i = 1; i < palette.length; i++) { // Skip background
      if (used[i]) continue;
      
      const group = [i];
      used[i] = true;
      const color1 = palette[i];
      
      for (let j = i + 1; j < palette.length; j++) {
        if (used[j]) continue;
        
        const color2 = palette[j];
        const distance = Math.sqrt(
          Math.pow(color1.r - color2.r, 2) +
          Math.pow(color1.g - color2.g, 2) +
          Math.pow(color1.b - color2.b, 2)
        );
        
        if (distance <= threshold) {
          group.push(j);
          used[j] = true;
        }
      }
      groups.push(group);
    }
    
    const newPalette = [palette[0]]; // Keep background
    const newLayers = [layers[0]];
    
    groups.forEach(group => {
      const repColor = palette[group[0]]; // Use first color as representative
      const mergedPaths = [];
      group.forEach(idx => {
        if (Array.isArray(layers[idx])) {
          mergedPaths.push(...layers[idx]);
        }
      });
      
      newPalette.push(repColor);
      newLayers.push(mergedPaths);
    });
    
    return { ...tracedata, palette: newPalette, layers: newLayers };
  }

  function shouldHideColor(color, index) {
    if (index === 0) return true; // Always hide background layer by default
    
    const luma = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
    if (color.a > 180 && luma >= 245) return true; // Hide near-white
    
    if (bgEstimate) {
      const distance = Math.abs(color.r - bgEstimate.r) + 
                       Math.abs(color.g - bgEstimate.g) + 
                       Math.abs(color.b - bgEstimate.b);
      if (distance <= 30) return true;
    }
    
    return false;
  }

  function layerHasPaths(layer) {
    return Array.isArray(layer) && layer.length > 0;
  }

  function buildTracedataSubset(sourceTracedata, indices) {
    if (!sourceTracedata) return null;
    
    // This function can now correctly handle index 0 for the background
    const layers = [];
    const palette = [];
    
    indices.forEach(idx => {
      if (sourceTracedata.layers[idx] && sourceTracedata.palette[idx]) {
        layers.push(JSON.parse(JSON.stringify(sourceTracedata.layers[idx])));
        palette.push(sourceTracedata.palette[idx]);
      }
    });
    
    return { ...sourceTracedata, layers, palette };
  }

  function getVisiblePaletteIndices() {
    if (!tracedata) return [];
    
    const indices = [];
    for (let i = 1; i < tracedata.palette.length; i++) { // Start at 1 to skip background
      const color = tracedata.palette[i];
      if (!shouldHideColor(color, i) && layerHasPaths(tracedata.layers[i])) {
        indices.push(i);
      }
    }
    return indices;
  }

  function displayPalette() {
    if (!tracedata || !elements.paletteContainer) return;
    
    elements.paletteContainer.innerHTML = '';
    const visibleIndices = getVisiblePaletteIndices();
    
    if (visibleIndices.length === 0 && !layerHasPaths(tracedata.layers[0])) {
      elements.paletteRow.style.display = 'none';
      return;
    }

    // Add Background (Layer 0) option
    const bgLabel = document.createElement('label');
    bgLabel.style.display = 'inline-block';
    bgLabel.style.margin = '4px 8px';
    bgLabel.style.cursor = 'pointer';
    const bgCheckbox = document.createElement('input');
    bgCheckbox.type = 'checkbox';
    bgCheckbox.dataset.index = 'bg';
    bgCheckbox.checked = false; 
    bgCheckbox.style.marginRight = '6px';
    const bgSwatch = document.createElement('span');
    Object.assign(bgSwatch.style, { display: 'inline-block', width: '20px', height: '20px', backgroundColor: '#000', border: '2px solid #333', borderRadius: '3px', verticalAlign: 'middle', marginLeft: '4px' });
    const bgInfo = document.createElement('small');
    bgInfo.textContent = ' Layer 0 (Background)';
    Object.assign(bgInfo.style, { marginLeft: '6px', color: '#666' });
    bgLabel.appendChild(bgCheckbox);
    bgLabel.appendChild(bgSwatch);
    bgLabel.appendChild(bgInfo);
    elements.paletteContainer.appendChild(bgLabel);

    visibleIndices.forEach(index => {
        const color = tracedata.palette[index];
        const label = document.createElement('label');
        label.style.display = 'inline-block';
        label.style.margin = '4px 8px';
        label.style.cursor = 'pointer';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.dataset.index = index;
        checkbox.style.marginRight = '6px';
        
        const swatch = document.createElement('span');
        Object.assign(swatch.style, { display: 'inline-block', width: '20px', height: '20px', backgroundColor: `rgba(${color.r},${color.g},${color.b},${color.a/255})`, border: '2px solid #333', borderRadius: '3px', verticalAlign: 'middle', marginLeft: '4px' });
        
        const colorInfo = document.createElement('small');
        colorInfo.textContent = ` Layer ${visibleIndices.indexOf(index) + 1}`;
        colorInfo.style.marginLeft = '6px';
        colorInfo.style.color = '#666';
        
        label.appendChild(checkbox);
        label.appendChild(swatch);
        label.appendChild(colorInfo);
        elements.paletteContainer.appendChild(label);
    });
    
    elements.paletteRow.style.display = 'table-row';
    
    // Add change listener with mutual exclusivity for background layer
    elements.paletteContainer.addEventListener('change', (e) => {
      if (e.target.type !== 'checkbox') return;
      const bgCb = elements.paletteContainer.querySelector('input[data-index="bg"]');
      const otherCbs = elements.paletteContainer.querySelectorAll('input[type="checkbox"]:not([data-index="bg"])');
      if (e.target.dataset.index === 'bg' && e.target.checked) {
        otherCbs.forEach(cb => cb.checked = false);
      } else if (e.target.dataset.index !== 'bg' && e.target.checked && bgCb) {
        bgCb.checked = false;
      }
      updateFilteredPreview();
    });
  }

  // **IMPROVED: This function now correctly previews the background layer**
  function updateFilteredPreview() {
    if (!tracedata || !elements.svgPreviewFiltered) return;
    const paletteEl = elements.paletteContainer;
    if (!paletteEl) return;

    const selectedCheckboxes = Array.from(paletteEl.querySelectorAll('input[type="checkbox"]:checked'));

    if (selectedCheckboxes.length === 0) {
        elements.svgPreviewFiltered.data = '';
        return;
    }

    // Check if background layer is selected
    if (selectedCheckboxes.some(cb => cb.dataset.index === 'bg')) {
        // Use the processed solid silhouette if available
        if (silhouetteUrl) {
            elements.svgPreviewFiltered.data = silhouetteUrl;
        } else {
            // Fallback: create black silhouette from all visible layers
            const visibleIndices = getVisiblePaletteIndices();
            if (visibleIndices.length > 0) {
                const holeRemovalLevel = 1; // Default to level 1
                const solidSilhouette = createSolidSilhouette(tracedata, holeRemovalLevel);
                if (solidSilhouette) {
                    const svgString = ImageTracer.getsvgstring(solidSilhouette, lastOptions);
                    const blob = new Blob([svgString], { type: 'image/svg+xml' });
                    elements.svgPreviewFiltered.data = URL.createObjectURL(blob);
                } else {
                    elements.svgPreviewFiltered.data = '';
                }
            } else {
                elements.svgPreviewFiltered.data = '';
            }
        }
        return;
    }

    // Handle regular layer selection
    const indicesToRender = selectedCheckboxes
        .map(cb => parseInt(cb.dataset.index, 10))
        .filter(idx => !isNaN(idx));

    const filteredData = buildTracedataSubset(tracedata, indicesToRender);

    if (filteredData && filteredData.layers.length > 0 && filteredData.layers.some(layer => layer.length > 0)) {
        const svgString = ImageTracer.getsvgstring(filteredData, lastOptions);
        const blob = new Blob([svgString], { type: 'image/svg+xml' });
        elements.svgPreviewFiltered.data = URL.createObjectURL(blob);
    } else {
        elements.svgPreviewFiltered.data = '';
    }
  }

  function renderColorButtons() {
    if (!elements.colorButtonsRow || !tracedata) {
      if (elements.colorButtonsRow) {
        elements.colorButtonsRow.style.display = 'none';
        elements.colorButtonsRow.innerHTML = '';
      }
      return;
    }
    
    const visibleIndices = getVisiblePaletteIndices();
    elements.colorButtonsRow.innerHTML = '';
    
    if (visibleIndices.length === 0) {
      elements.colorButtonsRow.style.display = 'none';
      return;
    }
    
    elements.colorButtonsRow.style.display = 'flex';
    
    visibleIndices.forEach((idx, ordinal) => {
      const color = tracedata.palette[idx];
      const button = document.createElement('button');
      
      button.innerHTML = `Layer ${ordinal + 1}<br>Download`;
      button.style.backgroundColor = `rgba(${color.r},${color.g},${color.b},${color.a/255})`;
      
      const luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
      button.style.color = luminance > 140 ? '#000' : '#fff';
      
      button.addEventListener('click', () => {
        const singleLayer = buildTracedataSubset(tracedata, [idx]);
        const hex = rgbToHex(color.r, color.g, color.b);
        const svgString = ImageTracer.getsvgstring(singleLayer, lastOptions);
        downloadSVG(svgString, `layer_${ordinal + 1}_${hex}`);
        elements.statusText.textContent = `üìê Layer ${ordinal + 1} downloaded for 3D printing!`;
      });
      
      elements.colorButtonsRow.appendChild(button);
    });
  }

  // --- Initialize Extension Context Menu Loading ---
  async function loadImageFromContextMenu() {
    if (typeof chrome === 'undefined' || !chrome.storage) return;
    
    try {
      elements.statusText.textContent = 'üîç Checking for context menu image...';
      const data = await chrome.storage.local.get('imageUrlToConvert');
      
      if (data.imageUrlToConvert) {
        await loadImageFromUrl(data.imageUrlToConvert);
        chrome.storage.local.remove('imageUrlToConvert');
      } else {
        elements.statusText.textContent = 'üéØ Ready for 3D printing magic! Import an image to start.';
      }
    } catch (error) {
      console.log('Not in extension context or no stored image');
      elements.statusText.textContent = 'üéØ Ready for 3D printing magic! Import an image to start.';
    }
  }

  // --- Test with Sample Images ---
  function addTestImageButtons() {
    if (elements.urlInput) {
      elements.urlInput.placeholder = 'Try: Batman logo, Superman logo, or any simple graphic URL';
    }
  }

  // --- Initialize Application ---
  function initializeApp() {
    addTestImageButtons();
    updateColorFeedback(parseInt(elements.colorPrecisionSlider.value));
    loadImageFromContextMenu();
    
    if (elements.presetSelect) {
      elements.presetSelect.value = '3dprint';
    }
    // Initialize merge UI on app load
    initializeMergeUI();
    
    console.log('üöÄ 3D Print SVG Converter initialized!');
  }

  // Start the application
  initializeApp();

  // Remove small holes and hairline slivers from a merged path set
function removeSmallHoles(paths, opts = {}) {
  const { areaThreshold = 0, minGapPx = 1 } = opts;
  const maxSlenderness = 1800; // larger = more aggressive

  const out = [];
  for (const p of paths) {
    if (p && p.isholepath) {
      const pts = getPathPoints(p);
      if (pts.length < 3) continue; // drop degenerate holes
      const area = Math.abs(polygonArea(pts));      // pixel^2
      const bbox = pathBBox(pts);
      const perim = approxPerimeter(pts);
      const slender = (perim * perim) / (area + 1); // high => skinny sliver
      const minDim = Math.min(bbox.w, bbox.h);

      // nuke tiny holes & hairline white seams
      if (area < areaThreshold || minDim <= minGapPx || slender > maxSlenderness) {
        continue; // skip this hole -> it gets filled
      }
    }
    out.push(p);
  }
  return out;
}

// Convert traced path segments to a point list
function getPathPoints(path) {
  const pts = [];
  if (!path || !Array.isArray(path.segments) || !path.segments.length) return pts;
  pts.push([path.segments[0].x1, path.segments[0].y1]);
  for (const seg of path.segments) pts.push([seg.x2, seg.y2]);
  return pts;
}

// Shoelace area (signed)
function polygonArea(pts) {
  let a = 0;
  for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
    const [xi, yi] = pts[i];
    const [xj, yj] = pts[j];
    a += (xj + xi) * (yj - yi);
  }
  return a / 2;
}

function pathBBox(pts) {
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const [x, y] of pts) {
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
  }
  return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
}

function approxPerimeter(pts) {
  let p = 0;
  for (let i = 1; i < pts.length; i++) {
    p += Math.hypot(pts[i][0] - pts[i - 1][0], pts[i][1] - pts[i - 1][1]);
  }
  p += Math.hypot(pts[0][0] - pts[pts.length - 1][0], pts[0][1] - pts[pts.length - 1][1]);
  return p;
}

function selectBackgroundLayerOnly() {
  const container = elements.paletteContainer;
  if (!container) return;
  const cbs = container.querySelectorAll('input[type="checkbox"]');
  cbs.forEach(cb => { cb.checked = (cb.dataset.index === 'bg'); });
}
});